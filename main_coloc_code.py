# -*- coding: utf-8 -*-
"""colocalization_code_HWT_250605.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OJLaHNc0eoyhDXD9EFfWbfS4-4W1qRAt
"""

#imports

import sif_parser


import numpy as np
from datetime import datetime, timedelta
import os
from os import listdir, mkdir
import re
import sif_parser

import pandas as pd
import matplotlib.pyplot as plt
import streamlit as st


from skimage.feature import peak_local_max
from skimage.feature import blob_log

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.colors import LogNorm


from scipy.ndimage import zoom
from scipy.ndimage import gaussian_filter
from scipy.optimize import curve_fit
from scipy.optimize import least_squares

from datetime import date
import textwrap

import seaborn as sns


def HWT_aesthetic():
    sns.set_style("ticks")
    sns.set_context("notebook", font_scale=1.5,
                    rc={"lines.linewidth": 2.5,
                        "axes.labelsize": 14,
                        "axes.titlesize": 16})
    sns.set_palette("muted6")  #pref'd are colorblind , tab20c , muted6 ,
    sns.despine()


#global variables:
pix_size_um = 0.1
sig_threshold = 0.3 #threshold to remove psfs greater than this sigma

# Region breakdown:
#    1 | 2
#    -----
#    3 | 4

"""# Functions"""

def integrate_sif(sif, threshold=1, region='all', signal='UCNP'):
    image_data, metadata = sif_parser.np_open(sif)
    image_data = image_data[0]  # (H, W)

    gainDAC = metadata['GainDAC']
    exposure_time = metadata['ExposureTime']
    accumulate_cycles = metadata['AccumulatedCycles']

    # Normalize counts → photons
    image_data_cps = image_data * (5.0 / gainDAC) / exposure_time / accumulate_cycles

    radius_um_fine = 0.3
    radius_pix_fine = int(radius_um_fine / pix_size_um)

    # --- Crop image if region specified ---
    region = str(region)
    if region == '3':
        image_data_cps = image_data_cps[0:256, 0:256]
    elif region == '4':
        image_data_cps = image_data_cps[0:256, 256:512]
    elif region == '1':
        image_data_cps = image_data_cps[256:512, 0:256]
    elif region == '2':
        image_data_cps = image_data_cps[256:512, 256:512]
    elif region == 'custom': #accounting for misaligned 638 beam on 250610
        image_data_cps = image_data_cps[312:512, 56:256]

    # else → 'all': use full image

    # --- Detect peaks ---
    smoothed_image = gaussian_filter(image_data_cps, sigma=1)
    threshold_abs = np.mean(smoothed_image) + threshold * np.std(smoothed_image)

    if signal == 'UCNP':
        coords = peak_local_max(smoothed_image, min_distance=5, threshold_abs=threshold_abs)
    else:
        blobs = blob_log(smoothed_image, min_sigma=1, max_sigma=3, num_sigma=5, threshold=5 * threshold)
        coords = blobs[:, :2]

    #print(f"{os.path.basename(sif)}: Found {len(coords)} peaks in region {region}")

    results = []
    for center_y, center_x in coords:
        # Extract subregion
        sub_img, x0_idx, y0_idx = extract_subregion(image_data_cps, center_x, center_y, radius_pix_fine)

        # Refine peak
        blurred = gaussian_filter(sub_img, sigma=1)
        local_peak = peak_local_max(blurred, num_peaks=1)
        if local_peak.shape[0] == 0:
            continue
        local_y, local_x = local_peak[0]
        center_x_refined = x0_idx + local_x
        center_y_refined = y0_idx + local_y

        # Extract finer subregion
        sub_img_fine, x0_idx_fine, y0_idx_fine = extract_subregion(
            image_data_cps, center_x_refined, center_y_refined, radius_pix_fine
        )
        # Interpolate to 20x20 grid (like MATLAB)
        interp_size = 20
        zoom_factor = interp_size / sub_img_fine.shape[0]
        sub_img_interp = zoom(sub_img_fine, zoom_factor, order=1)  # bilinear interpolation

        # Prepare grid
        # y_indices, x_indices = np.indices(sub_img_fine.shape)
        # x_coords = (x_indices + x0_idx_fine) * pix_size_um
        # y_coords = (y_indices + y0_idx_fine) * pix_size_um
        interp_shape = sub_img_interp.shape
        y_indices, x_indices = np.indices(interp_shape)
        x_coords = (x_indices / interp_shape[1] * sub_img_fine.shape[1] + x0_idx_fine) * pix_size_um
        y_coords = (y_indices / interp_shape[0] * sub_img_fine.shape[0] + y0_idx_fine) * pix_size_um

        x_flat = x_coords.ravel()
        y_flat = y_coords.ravel()
        z_flat = sub_img_interp.ravel() #∆ variable name 250604

        # Initial guess
        amp_guess = np.max(sub_img_fine)
        offset_guess = np.min(sub_img_fine)
        x0_guess = center_x_refined * pix_size_um
        y0_guess = center_y_refined * pix_size_um
        sigma_guess = 0.15
        p0 = [amp_guess, x0_guess, sigma_guess, y0_guess, sigma_guess, offset_guess]

        # Fit
        try:
            #popt, _ = curve_fit(gaussian2d, (x_flat, y_flat), z_flat, p0=p0)
            def residuals(params, x, y, z):
                A, x0, sx, y0, sy, offset = params
                model = A * np.exp(-((x - x0)**2 / (2 * sx**2) + (y - y0)**2 / (2 * sy**2))) + offset
                return model - z

            # Set bounds similar to MATLAB
            lb = [1, x0_guess - 1, 0.0, y0_guess - 1, 0.0, offset_guess * 0.5]
            ub = [2 * amp_guess, x0_guess + 1, 0.175, y0_guess + 1, 0.175, offset_guess * 1.2]

            # Perform fit
            res = least_squares(residuals, p0, args=(x_flat, y_flat, z_flat), bounds=(lb, ub))
            popt = res.x
            amp_fit, x0_fit, sigx_fit, y0_fit, sigy_fit, offset_fit = popt
            brightness_fit = 2 * np.pi * amp_fit * sigx_fit * sigy_fit / pix_size_um**2
            brightness_integrated = np.sum(sub_img_fine) - sub_img_fine.size * offset_fit

            if brightness_fit > 1e9 or brightness_fit < 50:
                print(f"Excluded peak for brightness {brightness_fit:.2e}")
                continue
            if sigx_fit > sig_threshold or sigy_fit > sig_threshold:
                print(f"Excluded peak for size {sigx_fit:.2f} um x {sigy_fit:.2f} um")
                continue

            # Note: coordinates are already RELATIVE to cropped image
            results.append({
                'x_pix': center_x_refined,
                'y_pix': center_y_refined,
                'x_um': x0_fit,
                'y_um': y0_fit,
                'amp_fit': amp_fit,
                'sigx_fit': sigx_fit,
                'sigy_fit': sigy_fit,
                'brightness_fit': brightness_fit,
                'brightness_integrated': brightness_integrated
            })

        except RuntimeError:
            continue

    df = pd.DataFrame(results)
    return df, image_data_cps

def plot_brightness(image_data_cps, df, ax=None):
    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 10))
    im = ax.imshow(image_data_cps + 1, cmap='magma', norm=LogNorm(), origin='lower')
    plt.colorbar(im, ax=ax, label='pps', fraction=0.046, pad=0.04)

    for _, row in df.iterrows():
        x_px = row['x_pix']
        y_px = row['y_pix']
        brightness_kpps = row['brightness_fit'] / 1000
        radius_px = 2 * max(row['sigx_fit'], row['sigy_fit']) / pix_size_um

        circle = Circle((x_px, y_px), radius_px, color='white', fill=False, linewidth=1.5, alpha=0.7)
        ax.add_patch(circle)

        ax.text(x_px + 7.5, y_px + 7.5, f"{brightness_kpps:.1f} kpps",
                color='white', fontsize=10, ha='center', va='center')

    ax.set_xlabel('x (px)')
    ax.set_ylabel('y (px)')

    if ax is None:
        plt.show()

def sort_UCNP_dye_sifs(directory, signal_ucnp=976, signal_dye=638):
    files = [f for f in os.listdir(directory) if f.endswith('.sif')]
    ucnp_files = []
    dye_files = []

    for f in files:
        full_path = os.path.join(directory, f)
        has_ucnp = str(signal_ucnp) in f
        has_dye = str(signal_dye) in f

        if has_ucnp and not has_dye:
            ucnp_files.append(full_path)
        elif has_dye and not has_ucnp:
            dye_files.append(full_path)
        elif has_ucnp and has_dye:
            print(f"Warning: file contains both excitation numbers → {f}")
        else:
            print(f"Warning: file contains neither excitation number → {f}")

    return ucnp_files, dye_files


def natural_sort_key(s):
    return [int(text) if text.isdigit() else text.lower() for text in re.split(r'(\d+)', s)]
# def match_ucnp_dye_files(ucnps, dyes):
#     # Sort files naturally to ensure proper order
#     ucnps.sort(key=natural_sort_key)
#     dyes.sort(key=natural_sort_key)

#     pairs = []
#     warnings = []

#     # Pair files based on sorted order
#     for ucnp_file, dye_file in zip(ucnps, dyes):
#         ucnp_idx = int(re.search(r'(\d+)\.sif$', ucnp_file).group(1))
#         dye_idx = int(re.search(r'(\d+)\.sif$', dye_file).group(1))

#         # Check if the files are sequential
#         if abs(ucnp_idx - dye_idx) == 1:
#             pairs.append((ucnp_file, dye_file))
#         else:
#             ucnp_file_name = os.path.basename(ucnp_file)
#             dye_file_name = os.path.basename(dye_file)
#             warnings.append(f"Potential mismatch: UCNP {ucnp_file_name} and Dye {dye_file_name} are not sequential.")

#     # Print warnings for non-sequential files
#     for warning in warnings:
#         print(warning)

#     return pairs


def match_ucnp_dye_files(ucnps, dyes):
    # 1. deterministic sorting
    ucnps_sorted = sorted(ucnps, key=natural_sort_key)
    dyes_sorted = sorted(dyes, key=natural_sort_key)

    # 2. build dye lookup
    dye_map = {}
    for f in dyes_sorted:
        m = re.search(r'(\d+)\.sif$', f)
        if m:
            dye_map[int(m.group(1))] = f

    pairs = []
    warnings = []
    matched_dyes = set()

    # 3. for each UCNP, try forward then backward, skipping used dyes
    for ucnp_file in ucnps_sorted:
        m = re.search(r'(\d+)\.sif$', ucnp_file)
        if not m:
            warnings.append(f"Could not parse UCNP index from {ucnp_file}")
            continue
        uidx = int(m.group(1))

        # candidate indices
        cand = []
        if (uidx + 1) in dye_map and (uidx + 1) not in matched_dyes:
            cand.append(uidx + 1)
        if (uidx - 1) in dye_map and (uidx - 1) not in matched_dyes:
            cand.append(uidx - 1)

        if not cand:
            # no unmatched forward/backward
            expected = []
            if (uidx+1) in dye_map: expected.append(str(uidx+1))
            if (uidx-1) in dye_map: expected.append(str(uidx-1))
            if expected:
                warnings.append(
                    f"Both candidate dyes {', '.join(expected)} for UCNP {os.path.basename(ucnp_file)} "
                    "are already matched to other UCNPs."
                )
            else:
                warnings.append(
                    f"No Dye file “{uidx+1}.sif or {uidx-1}.sif” found for UCNP {os.path.basename(ucnp_file)}"
                )
        else:
            # pick forward first if present, else backward
            chosen_idx = cand[0]
            pairs.append((ucnp_file, dye_map[chosen_idx]))
            matched_dyes.add(chosen_idx)

    # 4. report any warnings
    for w in warnings:
        print("Warning:", w)

    return pairs

def coloc_subplots(ucnps, dyes, df_dict, colocalization_radius=2, show_fits=True, save_SVG = False):
    n_pairs = min(len(ucnps), len(dyes))
    #per_file_matched = []
    all_matched_pairs = []


    required_cols = ['x_pix', 'y_pix', 'sigx_fit', 'sigy_fit', 'brightness_fit']
    if len(ucnps) != len(dyes):
      print(f"Warning: UCNP files ({len(ucnps)}) and Dye files ({len(dyes)}) have different lengths.")

    if len(ucnps) != len(dyes):
        print(f"Warning: UCNP files ({len(ucnps)}) and Dye files ({len(dyes)}) have different lengths.")


    ucnp_indices = [int(re.search(r'(\d+)\.sif$', f).group(1)) for f in ucnps]
    dye_indices = [int(re.search(r'(\d+)\.sif$', f).group(1)) for f in dyes]



    pairs = match_ucnp_dye_files(ucnps, dyes)

    # Flatten pairs into two separate lists for the rest of the function
    ucnps = [pair[0] for pair in pairs]
    dyes = [pair[1] for pair in pairs]
    n_pairs = len(pairs)
    fig, axes = plt.subplots(n_pairs, 2, figsize=(12, 6.5 * n_pairs))

    if n_pairs == 1:
        axes = np.array([axes])

    for i in range(n_pairs):
        per_file_matched = []
        ucnp_file = ucnps[i]
        dye_file = dyes[i]
        ucnp_file_name = os.path.basename(ucnp_file)
        dye_file_name = os.path.basename(dye_file)

        # Extract file IDs (numbers before .sif)
        ucnp_file_id = re.search(r'(\d+)\.sif$', ucnp_file_name)
        dye_file_id = re.search(r'(\d+)\.sif$', dye_file_name)

        print(f"Pair {i+1}:")
        print(f"  UCNP file: {ucnp_file_name}")
        print(f"  Dye file: {dye_file_name}")

        matched_ucnp = set()
        matched_dye = set()

        if ucnp_file_id and dye_file_id:
          ucnp_file_id = ucnp_file_id.group(1)
          dye_file_id = dye_file_id.group(1)

        ucnp_df, ucnp_img = df_dict[ucnp_file]
        dye_df, dye_img = df_dict[dye_file]

        # Determine if each DataFrame has the required columns
        ucnp_has_fit = all(col in ucnp_df.columns for col in required_cols)
        dye_has_fit = all(col in dye_df.columns for col in required_cols)

        # Initialize colocalization arrays
        colocalized_ucnp = np.zeros(len(ucnp_df), dtype=bool) if ucnp_has_fit else None
        colocalized_dye = np.zeros(len(dye_df), dtype=bool) if dye_has_fit else None

        # Perform colocalization only if both DataFrames have the required columns and show_fits is True
        if show_fits and ucnp_has_fit and dye_has_fit:
            for idx_ucnp, row_ucnp in ucnp_df.iterrows():
                x_ucnp, y_ucnp = row_ucnp['x_pix'], row_ucnp['y_pix']

                # compute distances to all *unmatched* dyes
                mask = ~dye_df.index.isin(matched_dye)
                dx = dye_df.loc[mask, 'x_pix'] - x_ucnp
                dy = dye_df.loc[mask, 'y_pix'] - y_ucnp
                distances = np.hypot(dx, dy)

                if distances.min() <= colocalization_radius:
                    best_dye_idx = distances.idxmin()
                    matched_ucnp.add(idx_ucnp)
                    matched_dye.add(best_dye_idx)

                    row_dye = dye_df.loc[best_dye_idx]

                    colocalized_ucnp[idx_ucnp] = True
                    closest_idx = distances.idxmin()
                    row_dye = dye_df.loc[closest_idx]
                    idx_dye = dye_df.index.get_loc(closest_idx)
                    colocalized_dye[idx_dye] = True


                    #update df with relevant fields
                    per_file_matched.append({
                        'ucnp_file': ucnp_file_id,
                        'dye_file': dye_file_id,
                        'ucnp_x': x_ucnp,
                        'ucnp_y': y_ucnp,
                        'ucnp_brightness': row_ucnp['brightness_fit'],
                        'dye_x': row_dye['x_pix'],
                        'dye_y': row_dye['y_pix'],
                        'dye_brightness': row_dye['brightness_fit'],
                        'distance': distances[closest_idx],
                        'x_um_ucnp': row_ucnp['x_um'],
                        'y_um_ucnp': row_ucnp['y_um'],
                        'sigx_ucnp': row_ucnp['sigx_fit'],
                        'sigy_ucnp': row_ucnp['sigy_fit'],
                        'x_um_dye': row_dye['x_um'],
                        'y_um_dye': row_dye['y_um'],
                        'sigx_dye': row_dye['sigx_fit'],
                        'sigy_dye': row_dye['sigy_fit']
                    })

            percent_ucnp_coloc = 100 * np.sum(colocalized_ucnp) / len(ucnp_df) if len(ucnp_df) > 0 else 0
            percent_dye_coloc = 100 * np.sum(colocalized_dye) / len(dye_df) if len(dye_df) > 0 else 0
        else:
            percent_ucnp_coloc = percent_dye_coloc = None
            matched_pairs = []

        all_matched_pairs.extend(per_file_matched)



        matched_pairs_df = pd.DataFrame(per_file_matched)


        # --- Plot UCNP ---
        ax_ucnp = axes[i, 0]
        im_ucnp = ax_ucnp.imshow(ucnp_img + 1, cmap='magma', origin='lower', norm=LogNorm())
        plt.colorbar(im_ucnp, ax=ax_ucnp, label='pps', fraction=0.046, pad=0.04)

        ucnp_basename = os.path.basename(ucnp_file)
        match = re.search(r'(\d+)\.sif$', ucnp_basename)
        file_number = match.group(1) if match else '?'
        wrapped_ucnp_basename = "\n".join(textwrap.wrap(ucnp_basename, width=35))


        if show_fits and ucnp_has_fit:
            for is_coloc, (_, row) in zip(colocalized_ucnp, ucnp_df.iterrows()):
                color = 'lime' if is_coloc else 'white'
                radius_px = 4 * max(row['sigx_fit'], row['sigy_fit']) / 0.1
                circle = Circle((row['x_pix'], row['y_pix']), radius_px, color=color, fill=False, linewidth=1.5, alpha=0.7)
                ax_ucnp.add_patch(circle)
                ax_ucnp.text(row['x_pix'] + 7.5, row['y_pix'] + 7.5,
                            f"{row['brightness_fit']/1000:.1f} kpps",
                            color=color, fontsize=8, ha='center', va='center')

            if percent_ucnp_coloc is not None:
                ax_ucnp.set_title(f"UCNP sif# {file_number}\n{wrapped_ucnp_basename}\n{percent_ucnp_coloc:.1f}% colocalized")
            else:
                ax_ucnp.set_title(f"UCNP sif# {file_number}\n{wrapped_ucnp_basename}\n[No colocalization data]")
        else:
            ax_ucnp.set_title(f"UCNP\n{wrapped_ucnp_basename}")

        ax_ucnp.set_xlabel('X (px)')
        ax_ucnp.set_ylabel('Y (px)')

        # --- Plot Dye ---
        ax_dye = axes[i, 1]
        im_dye = ax_dye.imshow(dye_img + 1, cmap='magma', origin='lower', norm=LogNorm())
        plt.colorbar(im_dye, ax=ax_dye, label='pps', fraction=0.046, pad=0.04)

        dye_basename = os.path.basename(dye_file)
        wrapped_dye_basename = "\n".join(textwrap.wrap(dye_basename, width=35))


        if show_fits and dye_has_fit:
            for is_coloc, (_, row) in zip(colocalized_dye, dye_df.iterrows()):
                color = 'lime' if is_coloc else 'white'
                radius_px = 4 * max(row['sigx_fit'], row['sigy_fit']) / pix_size_um
                circle = Circle((row['x_pix'], row['y_pix']), radius_px, color=color, fill=False, linewidth=1.5, alpha=0.7)
                ax_dye.add_patch(circle)
                ax_dye.text(row['x_pix'] + 7.5, row['y_pix'] + 7.5,
                            f"{row['brightness_fit']/1000:.1f} kpps",
                            color=color, fontsize=8, ha='center', va='center')

            match = re.search(r'(\d+)\.sif$', wrapped_dye_basename)
            file_number = match.group(1) if match else '?'
            ax_dye.set_title(f"Dye sif# {file_number}\n{wrapped_dye_basename}\n{percent_dye_coloc:.1f}% colocalized")
        else:
            ax_dye.set_title(f"Dye\n{wrapped_dye_basename}")

        ax_dye.set_xlabel('X (px)')
        ax_dye.set_ylabel('Y (px)')


    compiled_matched_df = pd.DataFrame(all_matched_pairs)
    plt.tight_layout()

    if save_SVG:
        expt_name = os.path.basename(file_path.rstrip('/'))
        expt_name = re.sub(r'[^\w\-_.]', '_', expt_name)
        todaydate = date.today().strftime("%Y%m%d")
        filename = f"{expt_name}_{todaydate}.svg"

        plt.savefig(filename)
        print(f"Saved in Colab VM as: {filename}")
        files.download(filename)  # This will prompt a browser download
    plt.show()
    return compiled_matched_df

def extract_subregion(image, x0, y0, radius_pix):
    x_start = int(max(x0 - radius_pix, 0))
    x_end = int(min(x0 + radius_pix + 1, image.shape[1]))
    y_start = int(max(y0 - radius_pix, 0))
    y_end = int(min(y0 + radius_pix + 1, image.shape[0]))
    return image[y_start:y_end, x_start:x_end], x_start, y_start

def gaussian2d(xy, amp, x0, sigma_x, y0, sigma_y, offset):
    x, y = xy
    return (amp * np.exp(-((x - x0)**2)/(2*sigma_x**2)) *
                 np.exp(-((y - y0)**2)/(2*sigma_y**2)) + offset).ravel()


def gaussian(x, amp, mu, sigma):
    return amp * np.exp(-(x - mu)**2 / (2 * sigma**2))


def HWT_aesthetic():
    sns.set_style("ticks")
    sns.set_context("notebook", font_scale=1.5,
                    rc={"lines.linewidth": 2.5,
                        "axes.labelsize": 14,
                        "axes.titlesize": 16})
    sns.set_palette("tab20c")  #pref'd are colorblind , tab20c , muted6 ,
    sns.despine()

"""# File Selection

"""

file_path = r'/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250731/Tm06Yb94_PMAO_KM_1to1k_976nm1500mA'
#file_path = r'/content/drive/Shareddrives/PengLab_Data_2024/Microscopy/HWT/202409/20240918/HWT04_019_Tm03Yb20@Si@N3@DBCO-DNA-Cy5_stock_976nm100mA_638nm80mA/Compiled_data_HWT_250609/' #best spaac result

"""# Check Thresholds"""

#check UCNP thresholding:
uploaded_file = st.file_uploader("Choose a .sif file", type=['sif'])
if uploaded_file is not None:
    # Save the file temporarily to disk
    with open(uploaded_file.name, "wb") as f:
        f.write(uploaded_file.getbuffer())
    st.write(f"Saved file: {uploaded_file.name}")

    ex_df, image_data = integrate_sif(uploaded_file.name, threshold=ucnp_threshold, region=ucnp_region, signal='UCNP')
    plot_brightness(image_data, ex_df, show_fits = False)


    ex_sif_brightness = []
    
    if 'brightness_fit' in ex_df.columns:
        ex_sif_brightness.append(ex_df['brightness_fit'].values)




    # Clip outliers
    # lower = np.percentile(sif_brightness, 1)
    # upper = 3*10**4#np.percentile(all_brightness, 99)
    # brightness_clipped = sif_brightness[(sif_brightness >= lower) & (sif_brightness <= upper)]
    fig, ax = plt.subplots(figsize=(8, 5))
    
    bins = np.linspace(np.min(ex_sif_brightness), np.max(ex_sif_brightness), 50)
    counts, edges, patches = ax.hist(ex_sif_brightness, bins=bins, edgecolor='black', color = '#bc5090')
    
    
    bin_centers = 0.5 * (edges[:-1] + edges[1:])
    
    p0 = [np.max(counts), np.mean(ex_sif_brightness), np.std(ex_sif_brightness)]
    try:
        popt, _ = curve_fit(gaussian, bin_centers, counts, p0=p0)
        amp, ucnp_mu, sigma = popt
        x_fit = np.linspace(edges[0], edges[-1], 500)
        y_fit = gaussian(x_fit, *popt)
        ax.plot(x_fit, y_fit, color = 'dodgerblue', label=f"Gaussian Fit\nμ = {ucnp_mu:.1f}, σ = {sigma:.1f}")
        ax.legend()
    except RuntimeError:
        print("Gaussian fit failed.")
    
    ax.set_title("UCNP Brightness  Histogram")
    ax.set_xlabel("Brightness (pps)")
    ax.set_ylabel("Count")
    plt.tight_layout()
    plt.show()

file = os.path.join(file_path, 'HWT05_155A_stock__638nm75mA_6.sif')
dye_region = 'custom'
dye_threshold = 25

df, image_data = integrate_sif(file, threshold = dye_threshold, region = dye_region, signal = 'dye')
plot_brightness(image_data, df)

"""# Fit Data"""

df_dict = {}

signal_ucnp = 976 #excitation number in filename
signal_dye = 638 #excitation number in filename

ucnp_list, dye_list = sort_UCNP_dye_sifs(file_path)

# Process UCNP files
for file in ucnp_list:
    df, cropped_img = integrate_sif(file, threshold=ucnp_threshold, region=ucnp_region, signal='UCNP')
    df_dict[file] = (df, cropped_img)

# Process dye  files
for file in dye_list:
    df, cropped_img = integrate_sif(file, threshold=dye_threshold, region=dye_region, signal='dye')
    df_dict[file] = (df, cropped_img)

# Plot and assign matched pairs to df
compiled_matched_df = coloc_subplots(ucnp_list, dye_list, df_dict, show_fits=False, save_SVG = True)

compiled_matched_df.head()

"""#Estimate Single UCNP / Dye Brightness"""

single_ucnp_directory = '/content/drive/Shareddrives/PengLab_Data_2025/Microscopy/HWT/202506/20250624/HWT05_119D_1to5k_976nm_300mA'
print(os.listdir(single_ucnp_directory))

sif_brightness = []
all_brightness = []


for sif in os.listdir(single_ucnp_directory):
    if sif.endswith('.sif'):
      print(f'Analyzing {sif}')
      sif_dir = os.path.join(single_ucnp_directory, sif)

      df, _ = integrate_sif(sif_dir, threshold=0.1, region=ucnp_region, signal='UCNP')
      if 'brightness_fit' in df.columns:
          sif_brightness.append(df['brightness_fit'].values)

      def gaussian(x, amp, mu, sigma):
          return amp * np.exp(-(x - mu)**2 / (2 * sigma**2))

all_brightness = np.concatenate(sif_brightness) if sif_brightness else np.array([])


# Clip outliers
lower = np.percentile(all_brightness, 1)
upper = 3*10**4#np.percentile(all_brightness, 99)
brightness_clipped = all_brightness[(all_brightness >= lower) & (all_brightness <= upper)]
fig, ax = plt.subplots(figsize=(8, 5))

bins = np.linspace(np.min(brightness_clipped), np.max(brightness_clipped), 50)
counts, edges, patches = ax.hist(brightness_clipped, bins=bins, edgecolor='black', color = '#bc5090')


bin_centers = 0.5 * (edges[:-1] + edges[1:])




p0 = [np.max(counts), np.mean(brightness_clipped), np.std(brightness_clipped)]
try:
    popt, _ = curve_fit(gaussian, bin_centers, counts, p0=p0)
    amp, ucnp_mu, sigma = popt
    x_fit = np.linspace(edges[0], edges[-1], 500)
    y_fit = gaussian(x_fit, *popt)
    ax.plot(x_fit, y_fit, color = 'dodgerblue', label=f"Gaussian Fit\nμ = {ucnp_mu:.1f}, σ = {sigma:.1f}")
    ax.legend()
except RuntimeError:
    print("Gaussian fit failed.")

ax.set_title("UCNP Brightness  Histogram")
ax.set_xlabel("Brightness (pps)")
ax.set_ylabel("Count")
ax.set_xlim(lower, upper)

plt.tight_layout()
plt.show()

single_ucnp_brightness = ucnp_mu

print(sif_brightness)

single_dye_directory = r'/content/drive/Shareddrives/PengLab_Data_2025/Microscopy/HWT/202506/20250616/HWT05_107_SaltAging_5uL_1to100_976nm1000mA_638nm75mA/'
print(os.listdir(single_dye_directory))

single_dye_file = os.path.join(single_dye_directory, 'HWT05_107_SaltAging_5uL_1to100_638nm75mA_8.sif')
single_dye_region = 'custom'
single_dye_threshold = 1

df, image_data = integrate_sif(single_dye_file, threshold = single_dye_threshold, region = single_dye_region, signal = 'dye')
plot_brightness(image_data, df)

all_brightness = []


df, _ = integrate_sif(single_dye_file, threshold=single_dye_threshold, region=single_dye_region, signal='dye')
if 'brightness_fit' in df.columns:
    all_brightness.extend(df['brightness_fit'].values)

def gaussian(x, amp, mu, sigma):
    return amp * np.exp(-(x - mu)**2 / (2 * sigma**2))

all_brightness = np.array(all_brightness)
print(f"Number of brightness_fit values: {len(all_brightness)}")

# Clip outliers
lower = np.percentile(all_brightness, 1)
upper = np.percentile(all_brightness, 99)
brightness_clipped = all_brightness[(all_brightness >= lower) & (all_brightness <= upper)]

fig, ax = plt.subplots(figsize=(8, 5))

bins = np.linspace(np.min(brightness_clipped), np.max(brightness_clipped), 50)
counts, edges, patches = ax.hist(brightness_clipped, bins=bins, edgecolor='black', color = '#bc5090')


bin_centers = 0.5 * (edges[:-1] + edges[1:])




p0 = [np.max(counts), np.mean(brightness_clipped), np.std(brightness_clipped)]
try:
    popt, _ = curve_fit(gaussian, bin_centers, counts, p0=p0)
    amp, dye_mu, sigma = popt
    x_fit = np.linspace(edges[0], edges[-1], 500)
    y_fit = gaussian(x_fit, *popt)
    ax.plot(x_fit, y_fit, color = 'dodgerblue', label=f"Gaussian Fit\nμ = {dye_mu:.1f}, σ = {sigma:.1f}")
    ax.legend()
except RuntimeError:
    print("Gaussian fit failed.")

ax.set_title("Single Dye Brightness  Histogram")
ax.set_xlabel("Brightness (pps)")
ax.set_ylabel("Count")
ax.set_xlim(lower, upper)

plt.tight_layout()
plt.show()

single_dye_brightness = dye_mu

single_ucnp_brightness = 3000 #temp, delete later
single_dye_brightness = 234

"""#Process Data:"""

#add estimated # ucnps and dyes:
save_df = True


compiled_matched_df['num_ucnps'] = compiled_matched_df['ucnp_brightness'] / single_ucnp_brightness
compiled_matched_df['num_dyes'] = compiled_matched_df['dye_brightness'] / single_dye_brightness

compiled_matched_df.head()

#threshold if ucnp_brightness < 0.3 * single_ucnp_brightness, exclude:

thresholded_df = compiled_matched_df[compiled_matched_df['ucnp_brightness'] >= 0.3 * single_ucnp_brightness]
thresholded_df.head()

if save_df:
    expt_name = os.path.basename(file_path.rstrip('/'))
    expt_name = re.sub(r'[^\w\-_.]', '_', expt_name)
    todaydate = date.today().strftime("%Y%m%d")
    filename = f"{expt_name}_{todaydate}.csv"  # Change extension from .svg to .csv

    thresholded_df.to_csv(filename, index=False)
    files.download(filename)

x = compiled_matched_df['num_ucnps'].values.reshape(-1, 1)
y = compiled_matched_df['num_dyes'].values

# Create subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# --- Plot 1: Full range ---
# model1 = LinearRegression().fit(x, y)
# y_pred1 = model1.predict(x)
# r2_1 = r2_score(y, y_pred1)
# slope1 = model1.coef_[0]
# intercept1 = model1.intercept_

ax1.scatter(x, y, alpha=0.6)
#ax1.plot(x, y_pred1, color='red', label=f'y = {slope1:.2f}x + {intercept1:.1f}\nR² = {r2_1:.2f}')
ax1.set_xlabel('Number of UCNPs per PSF')
ax1.set_ylabel('Number of Dyes per PSF')
#ax1.set_ylim([0, 500])

# --- Plot 2: Filtered range (y ≤ 125) ---

ax2.scatter(x, y, alpha=0.6)
#ax2.plot(x2, y_pred2, color='red', label=f'y = {slope2:.2f}x + {intercept2:.1f}\nR² = {r2_2:.2f}')
ax2.set_xlabel('Number of UCNPs per PSF')
ax2.set_ylabel('Number of Dyes per PSF')
ax2.set_xlim([0, 2])
ax2.set_ylim([0, 400])

plt.tight_layout()
plt.show()

# Filter for x in [0, 2]
mask = (thresholded_df['num_ucnps'] >= 0) & (thresholded_df['num_ucnps'] <= 2)
y_subset_300mA = thresholded_df.loc[mask, 'num_dyes']
mean_val = y_subset_300mA.mean()

# Plot histogram
plt.figure(figsize=(6, 4))
plt.hist(y_subset_300mA, bins=20, edgecolor='black', color='#bc5090')
plt.xlabel('Number of Dyes per Single UCNP')
plt.ylabel('Count')
plt.title(f'Mean = {mean_val:.1f}')
plt.tight_layout()

#plt.xlim([0, 150])
plt.show()

# plot multiple as violin plots:
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# --- PARAMETERS ---
# Dictionary mapping each condition label to its CSV path
condition_files = {
    "SPAAC, 05_135A: -20C, Vortexing": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250707/HWT05_125A_vortexed_1to50_SPAAC_976nm300mA_638nm75mA/HWT05_125A_vortexed_1to50_SPAAC_976nm300mA_638nm75mA_20250707.csv",
    "SPAAC, 05_135B: -20C, 10s sonication": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250707/HWT05_125B_sonicated_1to50_SPAAC_976nm300mA_638nm75mA/HWT05_125B_sonicated_1to50_SPAAC_976nm300mA_638nm75mA_20250707.csv",
    "SPAAC, 05_127: Saltaging": '/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250708/HWT05_127_saltaging_1to50_976nm300mA_638nm75mA/HWT05_127_saltaging_1to50_976nm300mA_638nm75mA_20250708.csv',
    "CuAAC, 02-129: Glove box": '/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250708/HWT05_129_cuaac_1to50_976nm300mA_638nm75mA/HWT05_129_cuaac_1to50_976nm300mA_638nm75mA_20250708.csv'
}
plot_order = list(condition_files.keys())



# --- PROCESS & COLLECT DATA ---
violin_data = []

for label, path in condition_files.items():
    # Load CSV
    df = pd.read_csv(path)

    # Estimate number of UCNPs and dyes
    df['num_ucnps'] = df['ucnp_brightness'] / single_ucnp_brightness
    df['num_dyes'] = df['dye_brightness'] / single_dye_brightness

    # Apply brightness threshold
    df_thresh = df[df['ucnp_brightness'] >= 0.3 * single_ucnp_brightness]

    # Filter for 0 <= num_ucnps <= 2
    mask = (df_thresh['num_ucnps'] >= 0) & (df_thresh['num_ucnps'] <= 2)
    dyes = df_thresh.loc[mask, 'num_dyes']


    # Append data for violin plot
    for value in dyes:
        violin_data.append({'Condition': label, 'Dyes per PSF': value})

# --- CREATE VIOLIN PLOT ---
violin_df = pd.DataFrame(violin_data)

plt.figure(figsize=(20, 5))
ax =sns.violinplot(data=violin_df, x='Condition', y='Dyes per PSF', inner='quartile', palette='tab20c', order = plot_order)
ax.set_ylim(bottom=0)

plt.ylabel("Number of Dyes per PSF")
plt.tight_layout()
HWT_aesthetic()

means = violin_df.groupby('Condition')['Dyes per PSF'].mean()
max_vals = violin_df.groupby('Condition')['Dyes per PSF'].max()

for i, condition in enumerate(plot_order):
    y = max_vals[condition]
    mu = means[condition]
    ax.text(i,1000, f'μ = {mu:.2f}',
            horizontalalignment='center', color='black', weight='bold', fontsize = 12)

plt.show()

test_path = r'/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250724/HWT05_155A_976nm300mA_638nm75mA/HWT05_155A_976nm300mA_638nm75mA_20250724.csv'
#file_path = r'/content/drive/Shareddrives/PengLab_Data_2024/Microscopy/HWT/202409/20240918/HWT04_019_Tm03Yb20@Si@N3@DBCO-DNA-Cy5_stock_976nm100mA_638nm80mA/Compiled_data_HWT_250609/' #best spaac result
#print(os.listdir(test_path))
df = pd.read_csv(test_path)

# plot multiple as box plots:
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import string

# --- PARAMETERS ---
# Dictionary mapping each condition label to its CSV path
condition_files = {
    "05_147A": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250721/05 147 Washed 10 times/HWT05_147A_1to50_976nm300mA_638nm75mA/HWT05_147A_1to50_976nm300mA_638nm75mA_20250725.csv",
     "05_147B": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250721/05 147 Washed 10 times/HWT05_147B_1to50_976nm300mA_638nm75mA/HWT05_147B_1to50_976nm300mA_638nm75mA_20250725.csv",
     "05_147C": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250721/05 147 Washed 10 times/HWT05_147C_1to50_976nm300mA_638nm75mA/HWT05_147C_1to50_976nm300mA_638nm75mA_20250725.csv",
   "05_155A": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250724/HWT05_155A_976nm300mA_638nm75mA/HWT05_155A_976nm300mA_638nm75mA_20250724.csv",
   "05_155B": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250724/HWT05_155B_976nm300mA_638nm75mA/HWT05_155B_976nm300mA_638nm75mA_20250724.csv",
   "05_155C": "/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250724/HWT05_155C_976nm300mA_638nm75mA/HWT05_155C_976nm300mA_638nm75mA_20250724.csv"

}
plot_order = list(condition_files.keys())

x_values = {
    "05_147A": 0.002, #mg of EDC
    "05_147B": 0.01,
    "05_147C": 0.1,
    "05_155A": 0.5,
    "05_155B": 1,
    "05_155C": 5
}
# --- PROCESS & COLLECT DATA ---
summary_data = []

for label, path in condition_files.items():
    df = pd.read_csv(path)
    df_thresh = df[df['ucnp_brightness'] >= 0.3 * single_ucnp_brightness]
    mask = (df_thresh['num_ucnps'] >= 0) & (df_thresh['num_ucnps'] <= 2)
    dyes = df_thresh.loc[mask, 'num_dyes']

    mean_val = dyes.mean()
    std_val = dyes.std()
    x_val = x_values[label]

    summary_data.append({'Condition': label, 'X': x_val, 'Mean': mean_val, 'STD': std_val})

summary_df = pd.DataFrame(summary_data)
summary_df = summary_df.sort_values(by='X').reset_index(drop=True)

# --- PLOT SCATTER WITH ERROR BARS ---
plt.figure(figsize=(8, 5))
plt.plot(summary_df['X'], summary_df['Mean'], color='grey', linestyle='-', zorder=1)

plt.errorbar(
    summary_df['X'],
    summary_df['Mean'],
    yerr=summary_df['STD'],
    fmt='o',
    ecolor='black',
    capsize=5,
    markersize=8,
)
for i, (x, y) in enumerate(zip(summary_df['X'], summary_df['Mean'])):
    label = string.ascii_lowercase[i]
    plt.text(x*1.2, y + 7.5, label, ha='center', va='bottom', fontsize=16)


plt.xscale('log')
plt.xlabel("EDC (mg)")
plt.ylabel("Number of Dyes per PSF")
plt.grid(True, which='both', linestyle='-', alpha=0.3)
plt.tight_layout()


HWT_aesthetic()

plt.show()

plt.scatter(thresholded_df['distance'], thresholded_df['num_dyes'], alpha=0.6)
plt.xlabel('Distance (um)')
plt.ylabel('Number of Dyes per PSF')
plt.show()
