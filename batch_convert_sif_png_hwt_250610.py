# -*- coding: utf-8 -*-
"""batch_convert_sif_png_HWT_250610.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18l3geMlBx2MfpoN-9L2tYa_klna6Ut9y
"""

#imports
try:
    import sif_parser
except ImportError:
    !pip install sif_parser
    import sif_parser

import numpy as np
from datetime import datetime, timedelta
import os
from os import listdir, mkdir
import re

from google.colab import drive
from google.colab import files


import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display
import ipywidgets as widgets

from skimage.feature import peak_local_max
from skimage.feature import blob_log

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.colors import LogNorm


from scipy.ndimage import zoom
from scipy.ndimage import gaussian_filter
from scipy.optimize import curve_fit
from scipy.optimize import least_squares

from datetime import date

import textwrap

#mount files from drive
drive.mount('/content/drive/', force_remount = True)

#global variables:
pix_size_um = 0.1
sig_threshold = 0.3 #threshold to remove psfs greater than this sigma

"""# Functions"""

def integrate_sif(sif, threshold=1, region='all', signal='UCNP'):
    image_data, metadata = sif_parser.np_open(sif)
    image_data = image_data[0]  # (H, W)

    gainDAC = metadata['GainDAC']
    if gainDAC == 0:
        gainDAC = 0.001 #avoid division by 0
    exposure_time = metadata['ExposureTime']
    accumulate_cycles = metadata['AccumulatedCycles']

    # Normalize counts → photons
    image_data_cps = image_data * (5.0 / gainDAC) / exposure_time / accumulate_cycles

    radius_um_fine = 0.3
    radius_pix_fine = int(radius_um_fine / pix_size_um)

    # --- Crop image if region specified ---
    region = str(region)
    if region == '3':
        image_data_cps = image_data_cps[0:256, 0:256]
    elif region == '4':
        image_data_cps = image_data_cps[0:256, 256:512]
    elif region == '1':
        image_data_cps = image_data_cps[256:512, 0:256]
    elif region == '2':
        image_data_cps = image_data_cps[256:512, 256:512]
    # else → 'all': use full image

    # --- Detect peaks ---
    smoothed_image = gaussian_filter(image_data_cps, sigma=1)
    threshold_abs = np.mean(smoothed_image) + threshold * np.std(smoothed_image)

    if signal == 'UCNP':
        coords = peak_local_max(smoothed_image, min_distance=5, threshold_abs=threshold_abs)
    else:
        blobs = blob_log(smoothed_image, min_sigma=1, max_sigma=3, num_sigma=5, threshold=5 * threshold)
        coords = blobs[:, :2]

    #print(f"{os.path.basename(sif)}: Found {len(coords)} peaks in region {region}")

    results = []
    for center_y, center_x in coords:
        # Extract subregion
        sub_img, x0_idx, y0_idx = extract_subregion(image_data_cps, center_x, center_y, radius_pix_fine)

        # Refine peak
        blurred = gaussian_filter(sub_img, sigma=1)
        local_peak = peak_local_max(blurred, num_peaks=1)
        if local_peak.shape[0] == 0:
            continue
        local_y, local_x = local_peak[0]
        center_x_refined = x0_idx + local_x
        center_y_refined = y0_idx + local_y

        # Extract finer subregion
        sub_img_fine, x0_idx_fine, y0_idx_fine = extract_subregion(
            image_data_cps, center_x_refined, center_y_refined, radius_pix_fine
        )
        # Interpolate to 20x20 grid (like MATLAB)
        interp_size = 20
        zoom_factor = interp_size / sub_img_fine.shape[0]
        sub_img_interp = zoom(sub_img_fine, zoom_factor, order=1)  # bilinear interpolation

        # Prepare grid
        # y_indices, x_indices = np.indices(sub_img_fine.shape)
        # x_coords = (x_indices + x0_idx_fine) * pix_size_um
        # y_coords = (y_indices + y0_idx_fine) * pix_size_um
        interp_shape = sub_img_interp.shape
        y_indices, x_indices = np.indices(interp_shape)
        x_coords = (x_indices / interp_shape[1] * sub_img_fine.shape[1] + x0_idx_fine) * pix_size_um
        y_coords = (y_indices / interp_shape[0] * sub_img_fine.shape[0] + y0_idx_fine) * pix_size_um

        x_flat = x_coords.ravel()
        y_flat = y_coords.ravel()
        z_flat = sub_img_interp.ravel() #∆ variable name 250604

        # Initial guess
        amp_guess = np.max(sub_img_fine)
        offset_guess = np.min(sub_img_fine)
        x0_guess = center_x_refined * pix_size_um
        y0_guess = center_y_refined * pix_size_um
        sigma_guess = 0.15
        p0 = [amp_guess, x0_guess, sigma_guess, y0_guess, sigma_guess, offset_guess]

        # Fit
        try:
            #popt, _ = curve_fit(gaussian2d, (x_flat, y_flat), z_flat, p0=p0)
            def residuals(params, x, y, z):
                A, x0, sx, y0, sy, offset = params
                model = A * np.exp(-((x - x0)**2 / (2 * sx**2) + (y - y0)**2 / (2 * sy**2))) + offset
                return model - z

            # Set bounds similar to MATLAB
            lb = [1, x0_guess - 1, 0.0, y0_guess - 1, 0.0, offset_guess * 0.5]
            ub = [2 * amp_guess, x0_guess + 1, 0.175, y0_guess + 1, 0.175, offset_guess * 1.2]

            # Perform fit
            res = least_squares(residuals, p0, args=(x_flat, y_flat, z_flat), bounds=(lb, ub))
            popt = res.x
            amp_fit, x0_fit, sigx_fit, y0_fit, sigy_fit, offset_fit = popt
            brightness_fit = 2 * np.pi * amp_fit * sigx_fit * sigy_fit / pix_size_um**2
            brightness_integrated = np.sum(sub_img_fine) - sub_img_fine.size * offset_fit

            if brightness_fit > 1e9:
                print(f"Excluded peak for brightness {brightness_fit:.2e}")
                continue
            if sigx_fit > sig_threshold or sigy_fit > sig_threshold:
                print(f"Excluded peak for size {sigx_fit:.2f} um x {sigy_fit:.2f} um")
                continue

            # Note: coordinates are already RELATIVE to cropped image
            results.append({
                'x_pix': center_x_refined,
                'y_pix': center_y_refined,
                'x_um': x0_fit,
                'y_um': y0_fit,
                'amp_fit': amp_fit,
                'sigx_fit': sigx_fit,
                'sigy_fit': sigy_fit,
                'brightness_fit': brightness_fit,
                'brightness_integrated': brightness_integrated
            })

        except RuntimeError:
            continue

    df = pd.DataFrame(results)
    return df, image_data_cps

def plot_brightness(image_data_cps, df, ax=None, normalization = LogNorm()):
    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 10))
    im = ax.imshow(image_data_cps + 1, cmap='magma', norm=normalization, origin='lower')
    plt.colorbar(im, ax=ax, label='pps', fraction=0.046, pad=0.04)

    for _, row in df.iterrows():
        x_px = row['x_pix']
        y_px = row['y_pix']
        brightness_kpps = row['brightness_fit'] / 1000
        radius_px = 2 * max(row['sigx_fit'], row['sigy_fit']) / pix_size_um

        circle = Circle((x_px, y_px), radius_px, color='white', fill=False, linewidth=1.5, alpha=0.7)
        ax.add_patch(circle)

        ax.text(x_px + 7.5, y_px + 7.5, f"{brightness_kpps:.1f} kpps",
                color='white', fontsize=10, ha='center', va='center')

    ax.set_xlabel('x (px)')
    ax.set_ylabel('y (px)')

    if ax is None:
        plt.show()

def sort_UCNP_dye_sifs(directory, signal_ucnp=976, signal_dye=638):
    files = [f for f in os.listdir(directory) if f.endswith('.sif')]
    ucnp_files = []
    dye_files = []

    for f in files:
        full_path = os.path.join(directory, f)
        has_ucnp = str(signal_ucnp) in f
        has_dye = str(signal_dye) in f

        if has_ucnp and not has_dye:
            ucnp_files.append(full_path)
        elif has_dye and not has_ucnp:
            dye_files.append(full_path)
        elif has_ucnp and has_dye:
            print(f"Warning: file contains both excitation numbers → {f}")
        else:
            print(f"Warning: file contains neither excitation number → {f}")

    return ucnp_files, dye_files



def plot_all_sifs(sif_files, df_dict, colocalization_radius=10, show_fits=True, save_SVG=False, normalization = LogNorm()):
    n_files = len(sif_files)
    n_cols = 4
    n_rows = (n_files + n_cols - 1) // n_cols  # Compute rows for a 4-column grid
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4 * n_rows))
    axes = axes.flatten()  # Flatten axes for easy iteration

    required_cols = ['x_pix', 'y_pix', 'sigx_fit', 'sigy_fit', 'brightness_fit']
    all_matched_pairs = []

    for i, sif_file in enumerate(sif_files):
        ax = axes[i]
        if sif_file not in df_dict:
            print(f"Warning: Data for {sif_file} not found in df_dict. Skipping.")
            continue

        df, img = df_dict[sif_file]
        has_fit = all(col in df.columns for col in required_cols)

        # Initialize colocalization array
        colocalized = np.zeros(len(df), dtype=bool) if has_fit else None

        # Perform colocalization
        if show_fits and has_fit:
            for idx, row in df.iterrows():
                x, y = row['x_pix'], row['y_pix']

                # Compute distances within the same file (self-colocalization, if applicable)
                distances = np.sqrt((df['x_pix'] - x) ** 2 + (df['y_pix'] - y) ** 2)
                distances[idx] = np.inf  # Ignore self-match
                if np.any(distances <= colocalization_radius):
                    colocalized[idx] = True
                    closest_idx = distances.idxmin()
                    all_matched_pairs.append({
                        'x': x, 'y': y, 'brightness': row['brightness_fit'],
                        'closest_x': df.at[closest_idx, 'x_pix'],
                        'closest_y': df.at[closest_idx, 'y_pix'],
                        'closest_brightness': df.at[closest_idx, 'brightness_fit'],
                        'distance': distances[closest_idx]
                    })

        # Plot the SIF image
        im = ax.imshow(img + 1, cmap='magma', origin='lower', norm=normalization)
        plt.colorbar(im, ax=ax, label='pps', fraction=0.046, pad=0.04)

        basename = os.path.basename(sif_file)
        match = re.search(r'(\d+)\.sif$', basename)
        file_number = match.group(1) if match else '?'

        # Overlay fits if available
        if show_fits and has_fit:
            for is_coloc, (_, row) in zip(colocalized, df.iterrows()):
                color = 'lime' if is_coloc else 'white'
                radius_px = 4 * max(row['sigx_fit'], row['sigy_fit']) / 0.1
                circle = Circle((row['x_pix'], row['y_pix']), radius_px, color=color, fill=False, linewidth=1.5, alpha=0.7)
                ax.add_patch(circle)
                ax.text(row['x_pix'] + 7.5, row['y_pix'] + 7.5,
                        f"{row['brightness_fit']/1000:.1f} kpps",
                        color=color, fontsize=8, ha='center', va='center')
        wrapped_basename = "\n".join(textwrap.wrap(basename, width=20))

        ax.set_title(f"Sif {file_number}\n{wrapped_basename}")
        ax.set_xlabel('X (px)')
        ax.set_ylabel('Y (px)')

    # Hide unused subplots
    for ax in axes[n_files:]:
        ax.axis('off')

    plt.tight_layout()

    if save_SVG:
        expt_name = basename
        todaydate = date.today().strftime("%Y%m%d")
        filename = f"{expt_name}_{todaydate}.svg"

        plt.savefig(filename)
        print(f"Saved as: {filename}")
        files.download(filename)  # This will prompt a browser download

    plt.show()

    # Return colocalization results if any
    if all_matched_pairs:
        return pd.DataFrame(all_matched_pairs)
    return None


def extract_subregion(image, x0, y0, radius_pix):
    x_start = int(max(x0 - radius_pix, 0))
    x_end = int(min(x0 + radius_pix + 1, image.shape[1]))
    y_start = int(max(y0 - radius_pix, 0))
    y_end = int(min(y0 + radius_pix + 1, image.shape[0]))
    return image[y_start:y_end, x_start:x_end], x_start, y_start

def gaussian2d(xy, amp, x0, sigma_x, y0, sigma_y, offset):
    x, y = xy
    return (amp * np.exp(-((x - x0)**2)/(2*sigma_x**2)) *
                 np.exp(-((y - y0)**2)/(2*sigma_y**2)) + offset).ravel()

"""#Run"""

file_path = r'/content/drive/Shared drives/PengLab_Data_2025/Microscopy/HWT/202507/20250731/Tm06Yb94_PMAO_KM_1to1k_976nm1500mA'
print(os.listdir(file_path))

"""#Threshold"""

#check UCNP thresholding:
file = os.path.join(file_path, 'Tm06Yb94_PMAO_KM_1to100k_976nm1500mA_1.sif')
ucnp_region = '1'
ucnp_threshold = 0.5


df, image_data = integrate_sif(file, threshold = ucnp_threshold, region = ucnp_region, signal = 'UCNP')
plot_brightness(image_data, df)

"""#Fit and Plot"""

df_dict = {}
#print(file_path)
for file in os.listdir(file_path):
    this_file = os.path.join(file_path, file)
    if os.path.isfile(this_file) and file.endswith('.sif'):
      df, cropped_img = integrate_sif(this_file, threshold=ucnp_threshold, region=ucnp_region, signal='UCNP')
      df_dict[file] = (df, cropped_img)

sif_files = os.listdir(file_path)

matched_df = plot_all_sifs(sif_files, df_dict, show_fits=False, save_SVG = True, normalization = LogNorm())

